// check memo
if (memo[n] != -1) return memo[n];

// staircase
return memo[n] = staircase(n-1) + staircase(n-2) + staircase(n-3);

// house
return  memo[i] = max(house[i] + heist(i+2), heist(i+1));

// flags
return memo[n] = flags(n-1) + flags(n-2);

// maxpath
return memo1[r][c] = grid[r][c] + max(maxPath(r, c+1), maxPath(r+1, c));

// tile
return memo[n] = (tile2xN(n - 1) + tile2xN(n - 2)) % MOD;

// note taken
int minimum = INT32_MAX;
    for (int note: notes) {
        int temp = coinChange(n - note);
        if (temp < minimum) {
            minimum = temp;
            taken[n] = note;
        }
    }
    return memo[n] = minimum + 1;
}